<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CARTAE â€” ãƒˆãƒ©ãƒ³ãƒ—ç‰Œã®è«–ç†ãƒ‘ã‚ºãƒ«</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,700;0,900;1,700&family=Noto+Serif+JP:wght@400;700&family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root {
    --paper:#f4efe6; --paper-dark:#e8e0ce; --ink:#1c1a14; --ink-light:#4a4535;
    --ink-muted:#9a917a; --spade:#1c1a14; --heart:#b03030; --accent-red:#b03030;
    --eq-color:#7a5c2a; --neq-color:#8a2020; --success:#2d6b3a;
    --border:#c8bfa8; --shadow:rgba(28,26,20,0.12);
  }
  * { box-sizing:border-box; margin:0; padding:0; }
  body { background:var(--paper); color:var(--ink); font-family:'Courier Prime','Courier New',monospace; min-height:100vh; display:flex; flex-direction:column; align-items:center; padding:32px 20px 60px; position:relative; }
  body::before { content:''; position:fixed; inset:0; background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='300' height='300'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.75' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='300' height='300' filter='url(%23n)' opacity='0.08'/%3E%3C/svg%3E"); opacity:0.04; pointer-events:none; z-index:1000; }
  .top-rule { width:100%; max-width:520px; display:flex; align-items:center; gap:12px; margin-bottom:24px; }
  .rule-line { flex:1; height:1.5px; background:var(--ink); }
  .rule-diamond { width:8px; height:8px; background:var(--ink); transform:rotate(45deg); flex-shrink:0; }
  .masthead { text-align:center; margin-bottom:6px; }
  .masthead-sub { font-family:'Courier Prime',monospace; font-size:0.6rem; letter-spacing:0.35em; text-transform:uppercase; color:var(--ink-muted); margin-bottom:6px; }
  h1 { font-family:'Playfair Display','Noto Serif JP',serif; font-size:clamp(3rem,10vw,5.5rem); font-weight:900; line-height:0.9; letter-spacing:-0.02em; color:var(--ink); margin-bottom:4px; }
  h1 .sol { color:var(--spade); } h1 .luna { color:var(--heart); }
  .masthead-tagline { font-family:'Noto Serif JP',serif; font-size:0.72rem; color:var(--ink-muted); letter-spacing:0.15em; margin-top:8px; font-style:italic; }
  .bottom-rule { width:100%; max-width:520px; height:3px; background:linear-gradient(to right,transparent,var(--ink) 20%,var(--ink) 80%,transparent); margin:12px 0 20px; }
  .rules-card { background:var(--paper-dark); border:1px solid var(--border); border-radius:2px; padding:10px 18px; margin-bottom:22px; max-width:480px; width:100%; box-shadow:2px 2px 0 var(--border); }
  .rules-title { font-size:0.55rem; letter-spacing:0.3em; text-transform:uppercase; color:var(--ink-muted); margin-bottom:7px; text-align:center; }
  .rules-grid { display:grid; grid-template-columns:1fr 1fr; gap:4px 16px; }
  .rule { font-size:0.65rem; color:var(--ink-light); display:flex; align-items:flex-start; gap:6px; line-height:1.4; }
  .rule-sym { flex-shrink:0; font-weight:700; }
  .timer-bar { display:flex; align-items:center; gap:16px; margin-bottom:12px; font-size:0.65rem; color:var(--ink-muted); }
  .timer-display { font-family:'Playfair Display',serif; font-size:1.3rem; font-weight:700; color:var(--ink); min-width:64px; text-align:center; }
  .timer-display.running { color:var(--heart); }
  .stats-toggle { font-family:'Courier Prime',monospace; font-size:0.58rem; letter-spacing:0.12em; text-transform:uppercase; padding:4px 10px; border:1px solid var(--border); background:var(--paper); color:var(--ink-muted); cursor:pointer; border-radius:2px; transition:all 0.12s; }
  .stats-toggle:hover { background:var(--paper-dark); color:var(--ink); }
  .stats-panel { display:none; background:var(--paper-dark); border:1.5px solid var(--ink); border-radius:2px; padding:14px 20px; margin-bottom:16px; max-width:480px; width:100%; box-shadow:3px 3px 0 var(--border); animation:slidedown 0.2s ease; }
  .stats-panel.show { display:block; }
  @keyframes slidedown { from{opacity:0;transform:translateY(-8px)} to{opacity:1;transform:translateY(0)} }
  .stats-title { font-size:0.55rem; letter-spacing:0.3em; text-transform:uppercase; color:var(--ink-muted); margin-bottom:10px; text-align:center; }
  .stats-grid { display:grid; grid-template-columns:repeat(3,1fr); gap:8px; }
  .stat-item { text-align:center; }
  .stat-val { font-family:'Playfair Display',serif; font-size:1.4rem; font-weight:700; color:var(--ink); line-height:1; }
  .stat-label { font-size:0.55rem; color:var(--ink-muted); letter-spacing:0.1em; margin-top:3px; }
  .stats-diff-tabs { display:flex; gap:0; border:1px solid var(--border); border-radius:2px; overflow:hidden; margin-bottom:10px; }
  .stats-diff-tab { font-family:'Courier Prime',monospace; font-size:0.58rem; letter-spacing:0.1em; padding:4px 12px; border:none; border-right:1px solid var(--border); background:var(--paper); color:var(--ink-muted); cursor:pointer; flex:1; transition:all 0.1s; }
  .stats-diff-tab:last-child { border-right:none; }
  .stats-diff-tab.active { background:var(--ink); color:var(--paper); }
  .nav-area { display:flex; align-items:center; gap:0; margin-bottom:16px; border:1.5px solid var(--ink); border-radius:2px; overflow:hidden; box-shadow:2px 2px 0 var(--border); }
  .diff-tab { font-family:'Courier Prime',monospace; font-size:0.62rem; letter-spacing:0.15em; text-transform:uppercase; padding:7px 16px; border:none; background:var(--paper); color:var(--ink-muted); cursor:pointer; transition:all 0.15s; border-right:1px solid var(--border); }
  .diff-tab:last-child { border-right:none; }
  .diff-tab:hover { background:var(--paper-dark); color:var(--ink); }
  .diff-tab.active { background:var(--ink); color:var(--paper); }
  .puzzle-nav { display:flex; align-items:center; gap:10px; margin-bottom:14px; font-size:0.65rem; color:var(--ink-muted); letter-spacing:0.1em; }
  .nav-btn { width:26px; height:26px; border:1.5px solid var(--border); background:var(--paper); border-radius:2px; cursor:pointer; font-size:0.9rem; display:flex; align-items:center; justify-content:center; transition:all 0.12s; color:var(--ink); box-shadow:1px 1px 0 var(--border); }
  .nav-btn:hover { background:var(--ink); color:var(--paper); border-color:var(--ink); }
  .puzzle-num { font-family:'Playfair Display',serif; font-size:1.1rem; font-weight:700; color:var(--ink); min-width:80px; text-align:center; }
  .counters { display:flex; gap:24px; margin-bottom:14px; align-items:center; }
  .counter { display:flex; align-items:center; gap:6px; }
  .counter-sym { font-size:1.2rem; }
  .counter-info { text-align:left; }
  .counter-val { font-family:'Playfair Display',serif; font-size:1.2rem; font-weight:700; line-height:1; }
  .counter-val.spade { color:var(--spade); } .counter-val.heart { color:var(--heart); }
  .counter-label { font-size:0.52rem; color:var(--ink-muted); letter-spacing:0.1em; text-transform:uppercase; }
  .counter-sep { width:1px; height:28px; background:var(--border); }
  .game-wrap { position:relative; display:inline-block; margin-bottom:18px; }
  .grid-frame { padding:3px; background:var(--ink); border-radius:2px; box-shadow:4px 4px 0 var(--ink-light),8px 8px 0 var(--border); }
  .grid { display:grid; grid-template-columns:repeat(6,1fr); gap:2px; background:var(--ink-muted); }
  .cell { width:clamp(48px,11.5vw,66px); height:clamp(48px,11.5vw,66px); background:var(--paper); cursor:pointer; display:flex; align-items:center; justify-content:center; font-size:clamp(1.3rem,3.5vw,1.8rem); transition:background 0.08s; position:relative; user-select:none; }
  .cell:hover:not(.locked) { background:var(--paper-dark); }
  .cell.locked { cursor:default; background:#ede6d8; }
  .cell.locked::after { content:''; position:absolute; inset:3px; border:1px solid rgba(28,26,20,0.12); pointer-events:none; }
  .cell.error { background:#f5ddd8 !important; animation:stamp 0.25s ease; }
  @keyframes stamp { 0%{transform:scale(1.08)} 60%{transform:scale(0.96)} 100%{transform:scale(1)} }
  @keyframes inkdrop { 0%{transform:scale(0);opacity:0} 60%{transform:scale(1.15)} 100%{transform:scale(1);opacity:1} }
  .cell.pop .cell-inner { animation:inkdrop 0.2s cubic-bezier(0.34,1.4,0.64,1); }
  .cell-inner { display:flex; align-items:center; justify-content:center; width:100%; height:100%; }
  .constraints-layer { position:absolute; inset:3px; pointer-events:none; z-index:10; }
  .constraint-badge { position:absolute; width:16px; height:16px; border-radius:50%; display:flex; align-items:center; justify-content:center; transform:translate(-50%,-50%); font-size:0.5rem; font-weight:700; font-family:'Courier Prime',monospace; box-shadow:0 0 0 2px var(--paper); }
  .constraint-badge.eq { background:var(--eq-color); color:var(--paper); }
  .constraint-badge.neq { background:var(--neq-color); color:var(--paper); }
  .controls { display:flex; gap:0; border:1.5px solid var(--ink); border-radius:2px; overflow:hidden; box-shadow:2px 2px 0 var(--border); margin-bottom:14px; }
  .ctrl-btn { font-family:'Courier Prime',monospace; font-size:0.62rem; letter-spacing:0.12em; text-transform:uppercase; padding:9px 18px; border:none; border-right:1px solid var(--border); background:var(--paper); color:var(--ink-light); cursor:pointer; transition:all 0.12s; }
  .ctrl-btn:last-child { border-right:none; }
  .ctrl-btn:hover { background:var(--paper-dark); color:var(--ink); }
  .ctrl-btn.primary { background:var(--ink); color:var(--paper); font-weight:700; }
  .ctrl-btn.primary:hover { background:var(--ink-light); }
  .status { font-size:0.65rem; letter-spacing:0.08em; color:var(--ink-muted); min-height:18px; text-align:center; font-style:italic; }
  .status.ok { color:var(--success); font-style:normal; font-weight:700; }
  .status.err { color:var(--accent-red); font-style:normal; }
  .progress-bar-wrap { width:100%; max-width:400px; height:3px; background:var(--border); border-radius:2px; margin:12px 0 0; overflow:hidden; }
  .progress-bar-fill { height:100%; background:var(--ink); transition:width 0.3s ease; border-radius:2px; }
  .completion-badge { display:inline-block; font-size:0.55rem; letter-spacing:0.15em; text-transform:uppercase; background:var(--success); color:var(--paper); padding:2px 8px; border-radius:1px; margin-left:8px; vertical-align:middle; opacity:0; transition:opacity 0.3s; }
  .completion-badge.show { opacity:1; }

  /* Generating overlay */
  .generating { display:none; position:fixed; inset:0; background:rgba(244,239,230,0.92); z-index:150; align-items:center; justify-content:center; flex-direction:column; gap:12px; }
  .generating.show { display:flex; }
  .gen-spinner { font-size:2.5rem; animation:spin 1.2s linear infinite; }
  @keyframes spin { to{transform:rotate(360deg)} }
  .gen-text { font-family:'Playfair Display',serif; font-size:1.2rem; color:var(--ink); }

  /* Win overlay */
  .win-overlay { display:none; position:fixed; inset:0; background:rgba(244,239,230,0.96); z-index:200; align-items:center; justify-content:center; flex-direction:column; gap:12px; overflow:hidden; }
  .win-overlay.show { display:flex; }
  .win-deco { font-size:3rem; animation:spinonce 0.6s ease; }
  @keyframes spinonce { 0%{transform:rotate(-180deg) scale(0);opacity:0} 100%{transform:rotate(0deg) scale(1);opacity:1} }
  .win-title { font-family:'Playfair Display',serif; font-size:clamp(2rem,8vw,4rem); font-weight:900; color:var(--ink); letter-spacing:-0.02em; animation:fadeup 0.5s 0.2s both ease; }
  .win-time { font-family:'Playfair Display',serif; font-size:1.4rem; color:var(--heart); font-weight:700; animation:fadeup 0.5s 0.35s both ease; }
  .win-sub { font-size:0.65rem; color:var(--ink-muted); letter-spacing:0.3em; text-transform:uppercase; animation:fadeup 0.5s 0.45s both ease; }
  .win-rule { width:120px; height:1.5px; background:var(--ink); animation:fadeup 0.5s 0.5s both ease; }
  .win-btn { font-family:'Courier Prime',monospace; font-size:0.7rem; letter-spacing:0.15em; text-transform:uppercase; padding:11px 28px; border:2px solid var(--ink); background:var(--ink); color:var(--paper); cursor:pointer; border-radius:2px; margin-top:4px; transition:all 0.15s; animation:fadeup 0.5s 0.6s both ease; }
  .win-btn:hover { background:transparent; color:var(--ink); }
  @keyframes fadeup { from{opacity:0;transform:translateY(12px)} to{opacity:1;transform:translateY(0)} }
  #confettiCanvas { position:fixed; inset:0; pointer-events:none; z-index:199; display:none; }
  #confettiCanvas.show { display:block; }
</style>
</head>
<body>

<canvas id="confettiCanvas"></canvas>

<div class="generating" id="generatingOverlay">
  <div class="gen-spinner">â™ </div>
  <div class="gen-text">å•é¡Œã‚’ç”Ÿæˆä¸­â€¦</div>
</div>

<div class="top-rule">
  <div class="rule-line"></div><div class="rule-diamond"></div>
  <div class="rule-line"></div><div class="rule-diamond"></div>
  <div class="rule-line"></div>
</div>
<div class="masthead">
  <div class="masthead-sub">ãƒˆãƒ©ãƒ³ãƒ—è«–ç†ãƒ‘ã‚ºãƒ« â—† Card Logic</div>
  <h1><span class="sol">CAR</span><span class="luna">TAE</span></h1>
  <div class="masthead-tagline">ã‚¹ãƒšãƒ¼ãƒ‰ã¨ãƒãƒ¼ãƒˆã‚’æ­£ã—ã„å ´æ‰€ã¸é…ç½®ã›ã‚ˆ</div>
</div>
<div class="bottom-rule"></div>

<div class="rules-card">
  <div class="rules-title">â—† éŠã³æ–¹ / How to Play â—†</div>
  <div class="rules-grid">
    <div class="rule"><span class="rule-sym" style="color:var(--spade)">â™ </span> å„è¡Œãƒ»åˆ—ã«ã‚¹ãƒšãƒ¼ãƒ‰3å€‹</div>
    <div class="rule"><span class="rule-sym" style="color:var(--heart)">â™¥</span> å„è¡Œãƒ»åˆ—ã«ãƒãƒ¼ãƒˆ3å€‹</div>
    <div class="rule"><span class="rule-sym">âœ•</span> åŒã˜è¨˜å·ã‚’3é€£ç¶šä¸å¯</div>
    <div class="rule"><span class="rule-sym" style="color:var(--eq-color)">ï¼</span> éš£æ¥ã‚»ãƒ«ãŒåŒã˜è¨˜å·</div>
    <div class="rule"><span class="rule-sym" style="color:var(--neq-color)">Ã—</span> éš£æ¥ã‚»ãƒ«ãŒç•°ãªã‚‹è¨˜å·</div>
    <div class="rule"><span class="rule-sym">å³ã‚¯ãƒª</span>ã§ç›´æ¥â™¥ã‚’é…ç½®</div>
  </div>
</div>

<div class="nav-area">
  <button class="diff-tab active" onclick="switchDiff('æ˜“',this)">æ˜“</button>
  <button class="diff-tab" onclick="switchDiff('ä¸­',this)">ä¸­</button>
  <button class="diff-tab" onclick="switchDiff('é›£',this)">é›£</button>
</div>

<div class="timer-bar">
  <div class="timer-display" id="timerDisplay">0:00</div>
  <span style="color:var(--border)">|</span>
  <button class="stats-toggle" onclick="toggleStats()">ğŸ“Š çµ±è¨ˆ</button>
</div>

<div class="stats-panel" id="statsPanel">
  <div class="stats-title">â—† æˆç¸¾ / Statistics â—†</div>
  <div class="stats-diff-tabs">
    <button class="stats-diff-tab active" onclick="switchStatsDiff('æ˜“',this)">æ˜“</button>
    <button class="stats-diff-tab" onclick="switchStatsDiff('ä¸­',this)">ä¸­</button>
    <button class="stats-diff-tab" onclick="switchStatsDiff('é›£',this)">é›£</button>
  </div>
  <div class="stats-grid">
    <div class="stat-item"><div class="stat-val" id="statSolved">0</div><div class="stat-label">ã‚¯ãƒªã‚¢æ•°</div></div>
    <div class="stat-item"><div class="stat-val" id="statTotal">âˆ</div><div class="stat-label">ç·å•é¡Œæ•°</div></div>
    <div class="stat-item"><div class="stat-val" id="statBest">--</div><div class="stat-label">ãƒ™ã‚¹ãƒˆ</div></div>
    <div class="stat-item"><div class="stat-val" id="statAvg">--</div><div class="stat-label">å¹³å‡æ™‚é–“</div></div>
    <div class="stat-item"><div class="stat-val" id="statStreak">0</div><div class="stat-label">é€£ç¶šã‚¯ãƒªã‚¢</div></div>
    <div class="stat-item"><div class="stat-val" id="statRate">--</div><div class="stat-label">ä»Šæ—¥</div></div>
  </div>
</div>

<div class="puzzle-nav">
  <button class="nav-btn" onclick="prevPuzzle()">â—€</button>
  <div class="puzzle-num" id="puzzleNum">No.1</div>
  <button class="nav-btn" onclick="nextPuzzle()">â–¶</button>
  <span id="completionBadge" class="completion-badge">æ¸ˆ</span>
</div>

<div class="counters">
  <div class="counter">
    <div class="counter-sym" style="color:var(--spade);font-size:1.4rem">â™ </div>
    <div class="counter-info">
      <div class="counter-val spade" id="spadeCount">0</div>
      <div class="counter-label">Spade</div>
    </div>
  </div>
  <div class="counter-sep"></div>
  <div class="counter">
    <div class="counter-sym" style="color:var(--heart);font-size:1.4rem">â™¥</div>
    <div class="counter-info">
      <div class="counter-val heart" id="heartCount">0</div>
      <div class="counter-label">Heart</div>
    </div>
  </div>
</div>

<div class="game-wrap">
  <div class="grid-frame">
    <div class="grid" id="grid"></div>
  </div>
  <div class="constraints-layer" id="constraintsLayer"></div>
</div>

<div class="progress-bar-wrap">
  <div class="progress-bar-fill" id="progressBar" style="width:0%"></div>
</div>

<div class="controls">
  <button class="ctrl-btn" onclick="resetPuzzle()">ãƒªã‚»ãƒƒãƒˆ</button>
  <button class="ctrl-btn primary" onclick="checkSolution()">ãƒã‚§ãƒƒã‚¯</button>
  <button class="ctrl-btn" onclick="showHint()">ãƒ’ãƒ³ãƒˆ</button>
</div>
<div class="status" id="status">å·¦ã‚¯ãƒªãƒƒã‚¯ã§â™ ã€å³ã‚¯ãƒªãƒƒã‚¯ã§â™¥ã€ã‚‚ã†ä¸€åº¦ã§ã‚¯ãƒªã‚¢</div>

<div class="win-overlay" id="winOverlay">
  <div class="win-deco">âœ¦</div>
  <div class="win-title">Solved!</div>
  <div class="win-time" id="winTime"></div>
  <div class="win-rule"></div>
  <div class="win-sub">ãƒ‘ã‚ºãƒ« ã‚¯ãƒªã‚¢</div>
  <button class="win-btn" onclick="closeWin()">æ¬¡ã®ãƒ‘ã‚ºãƒ«ã¸ â†’</button>
</div>

<script>
// ============================================================
//  PUZZLE GENERATOR  (JavaScript backtracking solver)
// ============================================================
const SIZE = 6;

function rng(seed) {
  // Mulberry32
  let s = seed >>> 0;
  return () => { s += 0x6D2B79F5; let t = Math.imul(s^s>>>15,1|s); t ^= t+Math.imul(t^t>>>7,61|t); return ((t^t>>>14)>>>0)/4294967296; };
}

function genSolution(rand) {
  const grid = Array.from({length:SIZE}, () => Array(SIZE).fill(0));
  function bt(row, col) {
    if (row === SIZE) return isValidSolution(grid);
    const [nr, nc] = col < SIZE-1 ? [row, col+1] : [row+1, 0];
    if (grid[row][col] !== 0) return bt(nr, nc);
    const vals = rand() < 0.5 ? [1,2] : [2,1];
    for (const v of vals) {
      grid[row][col] = v;
      if (quickOK(grid, row, col) && bt(nr, nc)) return true;
      grid[row][col] = 0;
    }
    return false;
  }
  return bt(0, 0) ? grid : null;
}

function quickOK(grid, row, col) {
  const c = col, r = row;
  if (c >= 2 && grid[r][c] === grid[r][c-1] && grid[r][c] === grid[r][c-2]) return false;
  if (r >= 2 && grid[r][c] === grid[r-1][c] && grid[r][c] === grid[r-2][c]) return false;
  return true;
}

function isValidSolution(grid) {
  for (let i = 0; i < SIZE; i++) {
    const row = grid[i];
    const col = grid.map(r => r[i]);
    if (row.filter(v=>v===1).length !== 3) return false;
    if (col.filter(v=>v===1).length !== 3) return false;
    for (let j = 0; j < SIZE-2; j++) {
      if (row[j] && row[j]===row[j+1] && row[j]===row[j+2]) return false;
      if (col[j] && col[j]===col[j+1] && col[j]===col[j+2]) return false;
    }
  }
  return true;
}

function checkConstraints(grid, cons) {
  for (const {r1,c1,r2,c2,type} of cons) {
    const v1=grid[r1][c1], v2=grid[r2][c2];
    if (!v1||!v2) continue;
    if (type==='eq' && v1!==v2) return false;
    if (type==='neq' && v1===v2) return false;
  }
  return true;
}

function countSolutions(pgOrig, cons, limit=2) {
  const g = pgOrig.map(r=>[...r]);
  let count = 0;
  function bt(row, col) {
    if (count >= limit) return;
    if (row === SIZE) {
      if (isValidSolution(g) && checkConstraints(g, cons)) count++;
      return;
    }
    const [nr, nc] = col < SIZE-1 ? [row, col+1] : [row+1, 0];
    if (g[row][col] !== 0) { bt(nr, nc); return; }
    for (const v of [1,2]) {
      g[row][col] = v;
      if (quickOK(g, row, col) && checkConstraints(g, cons)) bt(nr, nc);
      g[row][col] = 0;
    }
  }
  bt(0, 0);
  return count;
}

function makePuzzle(sol, nl, ncCount, rand) {
  const allPairs = [];
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE-1;c++) allPairs.push([r,c,r,c+1]);
  for (let r=0;r<SIZE-1;r++) for (let c=0;c<SIZE;c++) allPairs.push([r,c,r+1,c]);
  // Fisher-Yates shuffle with rand
  for (let i=allPairs.length-1;i>0;i--) {
    const j = Math.floor(rand()*(i+1));
    [allPairs[i],allPairs[j]]=[allPairs[j],allPairs[i]];
  }
  const cons = allPairs.slice(0, ncCount).map(([r1,c1,r2,c2]) => ({
    r1,c1,r2,c2, type: sol[r1][c1]===sol[r2][c2] ? 'eq' : 'neq'
  }));

  const cells = [];
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) cells.push([r,c]);
  for (let i=cells.length-1;i>0;i--) {
    const j=Math.floor(rand()*(i+1));
    [cells[i],cells[j]]=[cells[j],cells[i]];
  }
  const pg = Array.from({length:SIZE},()=>Array(SIZE).fill(0));
  for (let i=0;i<nl;i++) { const [r,c]=cells[i]; pg[r][c]=sol[r][c]; }

  if (countSolutions(pg, cons) === 1) return {grid:pg, solution:sol, constraints:cons};
  return null;
}

// Generate one puzzle synchronously (called from worker-like async wrapper)
function generateOne(diff, seedBase, attempt) {
  const CONFIGS = { 'æ˜“':[9,5], 'ä¸­':[6,8], 'é›£':[3,11] };
  const [nl, nc] = CONFIGS[diff];
  const rand = rng(seedBase + attempt * 997);
  const sol = genSolution(rand);
  if (!sol) return null;
  return makePuzzle(sol, nl, nc, rand);
}

// ============================================================
//  PUZZLE CACHE  â€” pre-generate a pool per difficulty
// ============================================================
const CACHE_SIZE = 3; // keep N puzzles ready per diff
const cache = { 'æ˜“':[], 'ä¸­':[], 'é›£':[] };
const generating = { 'æ˜“':false, 'ä¸­':false, 'é›£':false };
let seedCounter = Date.now();

async function fillCache(diff) {
  if (generating[diff]) return;
  generating[diff] = true;
  while (cache[diff].length < CACHE_SIZE) {
    let puzzle = null;
    let att = 0;
    while (!puzzle && att < 500) {
      puzzle = generateOne(diff, seedCounter++, att++);
      // yield every 20 attempts so browser doesn't freeze
      if (att % 20 === 0) await new Promise(r => setTimeout(r, 0));
    }
    if (puzzle) cache[diff].push(puzzle);
  }
  generating[diff] = false;
}

async function getPuzzle(diff) {
  // Show generating overlay if cache empty
  if (cache[diff].length === 0) {
    document.getElementById('generatingOverlay').classList.add('show');
    await fillCache(diff);
    document.getElementById('generatingOverlay').classList.remove('show');
  }
  const p = cache[diff].shift();
  // Refill in background
  fillCache(diff);
  return p;
}

// ============================================================
//  GAME STATE
// ============================================================
let currentDiff = 'æ˜“';
let currentIdx = 0;       // display number (1-based)
let puzzleCount = {'æ˜“':0,'ä¸­':0,'é›£':0}; // how many generated per diff
let currentPuzzle = null;
let userGrid = [];
let lockedCells = [];
let statsDiff = 'æ˜“';

// Stats: per diff, array of times (seconds)
const stats = {'æ˜“':{solved:0,times:[],streak:0,todaySolved:0}, 'ä¸­':{solved:0,times:[],streak:0,todaySolved:0}, 'é›£':{solved:0,times:[],streak:0,todaySolved:0}};
const completed = {}; // key -> time

// ---- Timer ----
let timerInterval=null, timerStart=null, timerSeconds=0, timerRunning=false;
function startTimer() {
  if (timerRunning) return;
  timerRunning=true; timerStart=Date.now()-timerSeconds*1000;
  document.getElementById('timerDisplay').classList.add('running');
  timerInterval=setInterval(()=>{ timerSeconds=Math.floor((Date.now()-timerStart)/1000); document.getElementById('timerDisplay').textContent=formatTime(timerSeconds); },500);
}
function stopTimer() { timerRunning=false; clearInterval(timerInterval); document.getElementById('timerDisplay').classList.remove('running'); }
function resetTimer() { stopTimer(); timerSeconds=0; document.getElementById('timerDisplay').textContent='0:00'; }
function formatTime(s) { return `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`; }

// ---- Stats ----
function switchStatsDiff(diff,btn) {
  statsDiff=diff;
  document.querySelectorAll('.stats-diff-tab').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  renderStats();
}
function renderStats() {
  const s=stats[statsDiff];
  document.getElementById('statSolved').textContent=s.solved;
  document.getElementById('statTotal').textContent='âˆ';
  const best=s.times.length?Math.min(...s.times):null;
  const avg=s.times.length?Math.round(s.times.reduce((a,b)=>a+b,0)/s.times.length):null;
  document.getElementById('statBest').textContent=best!==null?formatTime(best):'--';
  document.getElementById('statAvg').textContent=avg!==null?formatTime(avg):'--';
  document.getElementById('statStreak').textContent=s.streak;
  document.getElementById('statRate').textContent=s.todaySolved+'å•';
}
function toggleStats() {
  const p=document.getElementById('statsPanel');
  p.classList.toggle('show');
  if (p.classList.contains('show')) renderStats();
}

// ---- Puzzle management ----
async function switchDiff(diff,btn) {
  currentDiff=diff;
  document.querySelectorAll('.diff-tab').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  await loadNewPuzzle();
}

async function loadNewPuzzle() {
  const p = await getPuzzle(currentDiff);
  puzzleCount[currentDiff]++;
  currentIdx = puzzleCount[currentDiff];
  currentPuzzle = p;
  userGrid = p.grid.map(r=>[...r]);
  lockedCells = p.grid.map(r=>r.map(v=>v!==0));
  document.getElementById('puzzleNum').textContent=`No.${currentIdx}`;
  document.getElementById('completionBadge').classList.remove('show');
  renderGrid();
  renderConstraints();
  updateCounters();
  updateProgress();
  setStatus('');
  resetTimer();
}

async function nextPuzzle() { await loadNewPuzzle(); }

async function prevPuzzle() {
  // Can't go back to already-used generated puzzles â€” just generate new
  await loadNewPuzzle();
}

function initPuzzle() {
  // Re-init current puzzle (reset)
  if (!currentPuzzle) return;
  userGrid = currentPuzzle.grid.map(r=>[...r]);
  lockedCells = currentPuzzle.grid.map(r=>r.map(v=>v!==0));
  renderGrid();
  renderConstraints();
  updateCounters();
  updateProgress();
  setStatus('');
  resetTimer();
}

// ---- Render ----
function renderGrid() {
  const grid=document.getElementById('grid');
  grid.innerHTML='';
  for (let r=0;r<SIZE;r++) {
    for (let c=0;c<SIZE;c++) {
      const cell=document.createElement('div');
      cell.className='cell'+(lockedCells[r][c]?' locked':'');
      cell.dataset.r=r; cell.dataset.c=c;
      const inner=document.createElement('div');
      inner.className='cell-inner';
      inner.textContent=valToSym(userGrid[r][c]);
      if (userGrid[r][c]===2) inner.style.color='var(--heart)';
      cell.appendChild(inner);
      if (!lockedCells[r][c]) {
        cell.addEventListener('click', onCellClick);
        cell.addEventListener('contextmenu', onCellRightClick);
      }
      grid.appendChild(cell);
    }
  }
}

function valToSym(v) { return v===1?'â™ ':v===2?'â™¥':''; }

function setCellVal(cell, r, c, val) {
  userGrid[r][c]=val;
  const inner=cell.querySelector('.cell-inner');
  inner.textContent=valToSym(val);
  inner.style.color=val===2?'var(--heart)':val===1?'var(--spade)':'';
  cell.classList.remove('error');
  if (val!==0) { cell.classList.remove('pop'); void cell.offsetWidth; cell.classList.add('pop'); }
  if (!timerRunning && val!==0) startTimer();
  updateCounters(); updateProgress(); highlightErrors();
  if (userGrid.flat().every(v=>v!==0) && getErrors().length===0) setTimeout(showWin,300);
}

function onCellClick(e) {
  const cell=e.currentTarget, r=+cell.dataset.r, c=+cell.dataset.c;
  setCellVal(cell,r,c, userGrid[r][c]===0?1:userGrid[r][c]===1?2:0);
}
function onCellRightClick(e) {
  e.preventDefault();
  const cell=e.currentTarget, r=+cell.dataset.r, c=+cell.dataset.c;
  setCellVal(cell,r,c, userGrid[r][c]===2?0:2);
}

function updateCounters() {
  let sp=0,ht=0;
  userGrid.forEach(row=>row.forEach(v=>{if(v===1)sp++;if(v===2)ht++;}));
  document.getElementById('spadeCount').textContent=sp;
  document.getElementById('heartCount').textContent=ht;
}
function updateProgress() {
  document.getElementById('progressBar').style.width=(userGrid.flat().filter(v=>v!==0).length/(SIZE*SIZE)*100)+'%';
}

// ---- Validation ----
function getErrors() {
  const errors=new Set();
  for (let i=0;i<SIZE;i++) {
    checkLine(userGrid[i],i,'row',errors);
    checkLine(userGrid.map(r=>r[i]),i,'col',errors);
  }
  currentPuzzle.constraints.forEach(con=>{
    const v1=userGrid[con.r1][con.c1], v2=userGrid[con.r2][con.c2];
    if (!v1||!v2) return;
    if ((con.type==='eq'&&v1!==v2)||(con.type==='neq'&&v1===v2)) {
      errors.add(`${con.r1},${con.c1}`); errors.add(`${con.r2},${con.c2}`);
    }
  });
  return [...errors].map(s=>s.split(',').map(Number));
}
function checkLine(line,idx,type,errors) {
  for (let i=0;i<SIZE-2;i++)
    if (line[i]&&line[i]===line[i+1]&&line[i]===line[i+2])
      for (let k=i;k<=i+2;k++) errors.add(type==='row'?`${idx},${k}`:`${k},${idx}`);
  if (line.every(v=>v!==0)&&line.filter(v=>v===1).length!==3)
    for (let k=0;k<SIZE;k++) errors.add(type==='row'?`${idx},${k}`:`${k},${idx}`);
}
function highlightErrors() {
  document.querySelectorAll('.cell').forEach(c=>c.classList.remove('error'));
  getErrors().forEach(([r,c])=>{ const el=document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); if(el) el.classList.add('error'); });
}

function checkSolution() {
  if (userGrid.flat().some(v=>v===0)) { setStatus('æœªå…¥åŠ›ã®ã‚»ãƒ«ãŒã‚ã‚Šã¾ã™','err'); return; }
  highlightErrors();
  if (getErrors().length===0) showWin();
  else setStatus('ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚Šã¾ã™ â€” èµ¤ã„ã‚»ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„','err');
}

// ---- Win ----
function showWin() {
  stopTimer();
  const s=stats[currentDiff];
  s.solved++; s.streak++; s.todaySolved++;
  if (timerSeconds>0) s.times.push(timerSeconds);
  document.getElementById('completionBadge').classList.add('show');
  document.getElementById('winTime').textContent=`â± ${formatTime(timerSeconds)}`;
  document.getElementById('winOverlay').classList.add('show');
  startConfetti();
  if (document.getElementById('statsPanel').classList.contains('show')) renderStats();
}
async function closeWin() {
  document.getElementById('winOverlay').classList.remove('show');
  stopConfetti();
  await loadNewPuzzle();
}
function resetPuzzle() { initPuzzle(); }

function showHint() {
  const sol=currentPuzzle.solution;
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) {
    if (userGrid[r][c]===0) {
      const cell=document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      setCellVal(cell,r,c,sol[r][c]);
      setStatus(`ãƒ’ãƒ³ãƒˆï¼š${r+1}è¡Œ${c+1}åˆ— â†’ ${valToSym(sol[r][c])}`);
      return;
    }
  }
  setStatus('ã™ã¹ã¦å…¥åŠ›æ¸ˆã¿ã§ã™');
}
function setStatus(msg,type='') {
  const el=document.getElementById('status');
  el.textContent=msg||'å·¦ã‚¯ãƒªãƒƒã‚¯ã§â™ ã€å³ã‚¯ãƒªãƒƒã‚¯ã§â™¥ã€ã‚‚ã†ä¸€åº¦ã§ã‚¯ãƒªã‚¢';
  el.className='status '+type;
}

function renderConstraints() {
  const layer=document.getElementById('constraintsLayer');
  layer.innerHTML='';
  requestAnimationFrame(()=>{
    const lr=layer.getBoundingClientRect();
    currentPuzzle.constraints.forEach(con=>{
      const e1=document.querySelector(`.cell[data-r="${con.r1}"][data-c="${con.c1}"]`);
      const e2=document.querySelector(`.cell[data-r="${con.r2}"][data-c="${con.c2}"]`);
      if(!e1||!e2) return;
      const b1=e1.getBoundingClientRect(),b2=e2.getBoundingClientRect();
      const mx=((b1.left+b1.right)/2+(b2.left+b2.right)/2)/2-lr.left;
      const my=((b1.top+b1.bottom)/2+(b2.top+b2.bottom)/2)/2-lr.top;
      const badge=document.createElement('div');
      badge.className=`constraint-badge ${con.type}`;
      badge.textContent=con.type==='eq'?'ï¼':'Ã—';
      badge.style.left=mx+'px'; badge.style.top=my+'px';
      layer.appendChild(badge);
    });
  });
}

// ---- Confetti ----
let confettiParticles=[],confettiRAF=null;
function startConfetti() {
  const canvas=document.getElementById('confettiCanvas');
  canvas.classList.add('show'); canvas.width=window.innerWidth; canvas.height=window.innerHeight;
  const ctx=canvas.getContext('2d');
  const COLORS=['#1c1a14','#b03030','#c8bfa8','#7a5c2a','#2d6b3a','#4a4535'];
  const SYMS=['â™ ','â™¥','â™¦','â™£'];
  confettiParticles=Array.from({length:80},()=>({
    x:Math.random()*canvas.width, y:-20-Math.random()*100,
    vx:(Math.random()-0.5)*3, vy:2+Math.random()*3,
    rot:Math.random()*Math.PI*2, rotV:(Math.random()-0.5)*0.15,
    size:12+Math.random()*14, color:COLORS[Math.floor(Math.random()*COLORS.length)],
    sym:SYMS[Math.floor(Math.random()*SYMS.length)], alpha:1,
  }));
  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    let alive=false;
    confettiParticles.forEach(p=>{
      p.x+=p.vx; p.y+=p.vy; p.rot+=p.rotV;
      if (p.y>canvas.height*0.7) p.alpha-=0.015;
      if (p.alpha>0&&p.y<canvas.height+40) alive=true;
      ctx.save(); ctx.globalAlpha=Math.max(0,p.alpha);
      ctx.translate(p.x,p.y); ctx.rotate(p.rot);
      ctx.font=`${p.size}px serif`; ctx.fillStyle=p.color;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(p.sym,0,0); ctx.restore();
    });
    if (alive) confettiRAF=requestAnimationFrame(draw); else stopConfetti();
  }
  confettiRAF=requestAnimationFrame(draw);
}
function stopConfetti() {
  if (confettiRAF) cancelAnimationFrame(confettiRAF);
  const canvas=document.getElementById('confettiCanvas');
  canvas.classList.remove('show');
  canvas.getContext('2d').clearRect(0,0,canvas.width,canvas.height);
}

document.addEventListener('contextmenu',e=>{ if(e.target.closest('.cell')) e.preventDefault(); });

// ---- Boot ----
// Pre-fill caches for all difficulties in background, then show first puzzle
(async()=>{
  fillCache('ä¸­'); fillCache('é›£'); // start background generation
  await loadNewPuzzle(); // load first æ˜“ puzzle (will fill æ˜“ cache)
})();
</script>
</body>
</html>
