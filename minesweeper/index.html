<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MINE SWEEPER</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0a0a0f;
    --panel: #0f1218;
    --border: #1a2a3a;
    --accent: #00d4ff;
    --danger: #ff3c5a;
    --safe: #00ff9d;
    --warn: #ffb800;
    --dim: #4a6070;
    --cell-bg: #1e3045;
    --cell-hover: #2a4060;
    --cell-open: #0d1a22;
    --text: #c8e0f0;
  }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    background-image: 
      radial-gradient(ellipse at 20% 20%, rgba(0,212,255,0.04) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 80%, rgba(0,255,157,0.03) 0%, transparent 50%);
  }

  h1 {
    font-family: 'Orbitron', sans-serif;
    font-weight: 900;
    font-size: clamp(1.4rem, 4vw, 2.2rem);
    letter-spacing: 0.3em;
    color: var(--accent);
    text-shadow: 0 0 20px rgba(0,212,255,0.5), 0 0 60px rgba(0,212,255,0.2);
    margin-bottom: 4px;
  }

  .subtitle {
    font-size: 0.7rem;
    letter-spacing: 0.4em;
    color: var(--dim);
    margin-bottom: 24px;
  }

  .hud {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    max-width: 460px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-bottom: none;
    padding: 10px 16px;
    border-radius: 6px 6px 0 0;
  }

  .hud-box {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
  }

  .hud-label {
    font-size: 0.55rem;
    letter-spacing: 0.2em;
    color: var(--dim);
  }

  .hud-value {
    font-family: 'Orbitron', sans-serif;
    font-size: 1.4rem;
    font-weight: 700;
    color: var(--accent);
    text-shadow: 0 0 10px rgba(0,212,255,0.4);
    min-width: 60px;
    text-align: center;
  }

  .hud-value.danger { color: var(--danger); text-shadow: 0 0 10px rgba(255,60,90,0.4); }
  .hud-value.safe { color: var(--safe); text-shadow: 0 0 10px rgba(0,255,157,0.4); }

  #reset-btn {
    background: transparent;
    border: 1px solid var(--accent);
    color: var(--accent);
    font-family: 'Share Tech Mono', monospace;
    font-size: 1.4rem;
    width: 44px;
    height: 44px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #reset-btn:hover {
    background: rgba(0,212,255,0.1);
    box-shadow: 0 0 12px rgba(0,212,255,0.3);
  }

  .difficulty-bar {
    display: flex;
    gap: 0;
    width: 100%;
    max-width: 460px;
    border: 1px solid var(--border);
    border-top: none;
    border-bottom: none;
  }

  .diff-btn {
    flex: 1;
    padding: 6px;
    background: var(--panel);
    border: none;
    border-right: 1px solid var(--border);
    color: var(--dim);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.1em;
    cursor: pointer;
    transition: all 0.15s;
  }

  .diff-btn:last-child { border-right: none; }
  .diff-btn:hover { background: var(--cell-hover); color: var(--text); }
  .diff-btn.active { background: rgba(0,212,255,0.08); color: var(--accent); }

  .board-wrap {
    background: var(--panel);
    border: 1px solid var(--border);
    border-top: none;
    padding: 12px;
    border-radius: 0 0 6px 6px;
    overflow-x: auto;
    max-width: 95vw;
  }

  #board {
    display: grid;
    gap: 2px;
  }

  .cell {
    width: 30px;
    height: 30px;
    background: var(--cell-bg);
    border: 1px solid #2e5070;
    border-radius: 3px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 0.75rem;
    font-weight: bold;
    transition: background 0.1s, transform 0.05s;
    user-select: none;
    position: relative;
    font-family: 'Orbitron', sans-serif;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.06), inset 0 -1px 0 rgba(0,0,0,0.3);
  }

  .cell:hover:not(.open):not(.exploded) {
    background: var(--cell-hover);
    transform: scale(1.05);
  }

  .cell.open {
    background: var(--cell-open);
    border-color: #0d2030;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
    cursor: default;
  }

  .cell.flagged::after {
    content: 'üö©';
    font-size: 0.8rem;
  }

  .cell.mine-show::after {
    content: 'üí£';
    font-size: 0.85rem;
  }

  .cell.exploded {
    background: rgba(255,60,90,0.25);
    border-color: var(--danger);
    animation: explode 0.3s ease;
  }

  @keyframes explode {
    0% { transform: scale(1); }
    50% { transform: scale(1.3); }
    100% { transform: scale(1); }
  }

  .cell.open.revealed {
    animation: reveal 0.15s ease;
  }

  @keyframes reveal {
    0% { opacity: 0; transform: scale(0.8); }
    100% { opacity: 1; transform: scale(1); }
  }

  .n1 { color: #00aaff; }
  .n2 { color: var(--safe); }
  .n3 { color: var(--danger); }
  .n4 { color: #8844ff; }
  .n5 { color: #ff6600; }
  .n6 { color: #00ddcc; }
  .n7 { color: #ff44aa; }
  .n8 { color: var(--dim); }

  #message {
    margin-top: 16px;
    font-family: 'Orbitron', sans-serif;
    font-size: 1rem;
    letter-spacing: 0.2em;
    height: 28px;
    text-align: center;
    transition: all 0.3s;
  }

  #message.win { color: var(--safe); text-shadow: 0 0 20px rgba(0,255,157,0.6); animation: msgPulse 1s ease infinite alternate; }
  #message.lose { color: var(--danger); text-shadow: 0 0 20px rgba(255,60,90,0.6); }

  @keyframes msgPulse {
    from { opacity: 0.7; letter-spacing: 0.2em; }
    to   { opacity: 1; letter-spacing: 0.35em; text-shadow: 0 0 30px rgba(0,255,157,0.9), 0 0 60px rgba(0,255,157,0.4); }
  }

  .cell.win-flash { animation: winFlash 0.5s ease forwards; }

  @keyframes winFlash {
    0%   { background: var(--cell-open); border-color: #0d2030; }
    40%  { background: rgba(0,255,157,0.35); border-color: var(--safe); box-shadow: 0 0 10px rgba(0,255,157,0.5); }
    100% { background: rgba(0,255,157,0.08); border-color: rgba(0,255,157,0.3); }
  }

  .cell.flag-win { animation: flagWin 0.5s ease forwards; }

  @keyframes flagWin {
    0%   { transform: scale(1); }
    50%  { transform: scale(1.3) rotate(10deg); filter: brightness(2); }
    100% { transform: scale(1) rotate(0deg); }
  }

  #particle-canvas {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none; z-index: 999;
  }

  #overlay-msg {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0);
    font-family: 'Orbitron', sans-serif; font-weight: 900;
    font-size: clamp(2rem, 8vw, 4rem); letter-spacing: 0.2em;
    color: var(--safe);
    text-shadow: 0 0 40px rgba(0,255,157,0.8), 0 0 80px rgba(0,255,157,0.4);
    z-index: 1000; pointer-events: none;
    transition: transform 0.4s cubic-bezier(0.175,0.885,0.32,1.275), opacity 0.4s;
    opacity: 0; white-space: nowrap;
  }
  #overlay-msg.show { transform: translate(-50%,-50%) scale(1); opacity: 1; }
  #overlay-msg.hide { transform: translate(-50%,-50%) scale(1.2); opacity: 0; }

  .instructions {
    margin-top: 20px;
    font-size: 0.6rem;
    color: var(--dim);
    letter-spacing: 0.15em;
    text-align: center;
    line-height: 1.8;
  }
</style>
</head>
<body>

<h1>MINESWEEPER</h1>
<p class="subtitle">TACTICAL DEMINING SYSTEM v2.0</p>

<div class="hud">
  <div class="hud-box">
    <span class="hud-label">MINES</span>
    <span class="hud-value danger" id="mine-count">--</span>
  </div>
  <button id="reset-btn" title="„É™„Çª„ÉÉ„Éà">‚ü≥</button>
  <div class="hud-box">
    <span class="hud-label">TIME</span>
    <span class="hud-value" id="timer">000</span>
  </div>
</div>

<div class="difficulty-bar">
  <button class="diff-btn active" data-rows="9" data-cols="9" data-mines="10">EASY</button>
  <button class="diff-btn" data-rows="16" data-cols="16" data-mines="40">NORMAL</button>
  <button class="diff-btn" data-rows="16" data-cols="30" data-mines="99">HARD</button>
</div>

<div class="board-wrap">
  <div id="board"></div>
</div>

<div id="message"></div>
<canvas id="particle-canvas"></canvas>
<div id="overlay-msg">AREA SECURED</div>

<div class="instructions">
  Â∑¶„ÇØ„É™„ÉÉ„ÇØ: „Éû„Çπ„ÇíÈñã„Åè„ÄÄ„ÄÄÂè≥„ÇØ„É™„ÉÉ„ÇØ: Êóó„ÇíÁ´ã„Å¶„Çã / Â§ñ„Åô
</div>

<script>
  let rows, cols, totalMines;
  let board, mineSet, revealed, flagged;
  let gameOver, gameStarted;
  let timerInterval, timeElapsed;
  let currentDiff = 0;

  const boardEl = document.getElementById('board');
  const mineCountEl = document.getElementById('mine-count');
  const timerEl = document.getElementById('timer');
  const messageEl = document.getElementById('message');
  const resetBtn = document.getElementById('reset-btn');

  const diffBtns = document.querySelectorAll('.diff-btn');
  diffBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      diffBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      rows = +btn.dataset.rows;
      cols = +btn.dataset.cols;
      totalMines = +btn.dataset.mines;
      initGame();
    });
  });

  resetBtn.addEventListener('click', initGame);

  function initGame() {
    const btn = document.querySelector('.diff-btn.active');
    rows = +btn.dataset.rows;
    cols = +btn.dataset.cols;
    totalMines = +btn.dataset.mines;

    board = Array.from({length: rows}, () => Array(cols).fill(0));
    mineSet = new Set();
    revealed = Array.from({length: rows}, () => Array(cols).fill(false));
    flagged = Array.from({length: rows}, () => Array(cols).fill(false));
    gameOver = false;
    gameStarted = false;

    clearInterval(timerInterval);
    timeElapsed = 0;
    timerEl.textContent = '000';
    timerEl.className = 'hud-value';
    mineCountEl.textContent = totalMines.toString().padStart(3, '0');
    messageEl.textContent = '';
    messageEl.className = '';

    renderBoard();
  }

  function placeMines(firstR, firstC) {
    const avoid = new Set();
    for (let dr = -1; dr <= 1; dr++)
      for (let dc = -1; dc <= 1; dc++) {
        const nr = firstR + dr, nc = firstC + dc;
        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols)
          avoid.add(nr * cols + nc);
      }

    while (mineSet.size < totalMines) {
      const idx = Math.floor(Math.random() * rows * cols);
      if (!avoid.has(idx)) mineSet.add(idx);
    }

    for (let r = 0; r < rows; r++)
      for (let c = 0; c < cols; c++)
        board[r][c] = 0;

    mineSet.forEach(idx => {
      const r = Math.floor(idx / cols), c = idx % cols;
      board[r][c] = -1;
    });

    for (let r = 0; r < rows; r++)
      for (let c = 0; c < cols; c++) {
        if (board[r][c] === -1) continue;
        let count = 0;
        for (let dr = -1; dr <= 1; dr++)
          for (let dc = -1; dc <= 1; dc++) {
            const nr = r+dr, nc = c+dc;
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && board[nr][nc] === -1) count++;
          }
        board[r][c] = count;
      }
  }

  function renderBoard() {
    boardEl.style.gridTemplateColumns = `repeat(${cols}, 30px)`;
    boardEl.innerHTML = '';
    for (let r = 0; r < rows; r++)
      for (let c = 0; c < cols; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.r = r;
        cell.dataset.c = c;
        cell.addEventListener('click', handleClick);
        cell.addEventListener('contextmenu', handleRightClick);
        boardEl.appendChild(cell);
      }
  }

  function getCell(r, c) {
    return boardEl.children[r * cols + c];
  }

  function handleClick(e) {
    if (gameOver) return;
    const r = +e.currentTarget.dataset.r;
    const c = +e.currentTarget.dataset.c;
    if (flagged[r][c] || revealed[r][c]) return;

    if (!gameStarted) {
      gameStarted = true;
      placeMines(r, c);
      timerInterval = setInterval(() => {
        timeElapsed++;
        timerEl.textContent = Math.min(timeElapsed, 999).toString().padStart(3, '0');
      }, 1000);
    }

    if (board[r][c] === -1) {
      // explode
      revealed[r][c] = true;
      const cell = getCell(r, c);
      cell.className = 'cell exploded';
      showAllMines(r, c);
      gameOver = true;
      clearInterval(timerInterval);
      timerEl.className = 'hud-value danger';
      messageEl.textContent = '[ DETONATION DETECTED ]';
      messageEl.className = 'lose';
    } else {
      flood(r, c);
      checkWin();
    }
  }

  function flood(r, c) {
    if (r < 0 || r >= rows || c < 0 || c >= cols) return;
    if (revealed[r][c] || flagged[r][c]) return;
    revealed[r][c] = true;
    const cell = getCell(r, c);
    cell.className = 'cell open revealed';
    const v = board[r][c];
    if (v > 0) {
      cell.textContent = v;
      cell.classList.add('n' + v);
    }
    if (v === 0) {
      for (let dr = -1; dr <= 1; dr++)
        for (let dc = -1; dc <= 1; dc++)
          flood(r+dr, c+dc);
    }
  }

  function handleRightClick(e) {
    e.preventDefault();
    if (gameOver) return;
    const r = +e.currentTarget.dataset.r;
    const c = +e.currentTarget.dataset.c;
    if (revealed[r][c]) return;
    flagged[r][c] = !flagged[r][c];
    const cell = getCell(r, c);
    cell.className = flagged[r][c] ? 'cell flagged' : 'cell';
    const flags = flagged.flat().filter(Boolean).length;
    mineCountEl.textContent = (totalMines - flags).toString().padStart(3, '0');
  }

  function showAllMines(explodeR, explodeC) {
    mineSet.forEach(idx => {
      const r = Math.floor(idx / cols), c = idx % cols;
      if (r === explodeR && c === explodeC) return;
      if (!revealed[r][c]) {
        const cell = getCell(r, c);
        cell.className = 'cell mine-show';
      }
    });
  }

  function checkWin() {
    let unopened = 0;
    for (let r = 0; r < rows; r++)
      for (let c = 0; c < cols; c++)
        if (!revealed[r][c]) unopened++;
    if (unopened === totalMines) {
      gameOver = true;
      clearInterval(timerInterval);
      timerEl.className = 'hud-value safe';
      messageEl.textContent = '[ AREA SECURED ]';
      messageEl.className = 'win';
      playWinAnimation();
    }
  }

  // --- Win Animation ---
  const canvas = document.getElementById('particle-canvas');
  const ctx = canvas.getContext('2d');
  const overlayMsg = document.getElementById('overlay-msg');
  let particles = [];
  let animFrame;

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  function spawnParticles(count) {
    const colors = ['#00ff9d','#00d4ff','#ffb800','#ffffff','#88ffcc'];
    for (let i = 0; i < count; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height * 0.6,
        vx: (Math.random() - 0.5) * 4,
        vy: Math.random() * -6 - 2,
        size: Math.random() * 5 + 2,
        color: colors[Math.floor(Math.random() * colors.length)],
        alpha: 1,
        life: 1,
        decay: Math.random() * 0.015 + 0.008,
        shape: Math.random() > 0.5 ? 'circle' : 'rect',
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.15,
        trail: []
      });
    }
  }

  function animateParticles() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    particles = particles.filter(p => p.alpha > 0.01);

    for (const p of particles) {
      p.trail.push({x: p.x, y: p.y, alpha: p.alpha});
      if (p.trail.length > 6) p.trail.shift();

      // draw trail
      for (let i = 0; i < p.trail.length - 1; i++) {
        const t = p.trail[i];
        ctx.save();
        ctx.globalAlpha = t.alpha * (i / p.trail.length) * 0.3;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(t.x, t.y, p.size * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      p.x += p.vx;
      p.vy += 0.12; // gravity
      p.y += p.vy;
      p.alpha -= p.decay;
      p.rotation += p.rotSpeed;

      ctx.save();
      ctx.globalAlpha = p.alpha;
      ctx.fillStyle = p.color;
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 8;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rotation);

      if (p.shape === 'circle') {
        ctx.beginPath();
        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillRect(-p.size, -p.size, p.size * 2, p.size * 2);
      }
      ctx.restore();
    }

    if (particles.length > 0) {
      animFrame = requestAnimationFrame(animateParticles);
    } else {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  }

  function playWinAnimation() {
    // 1. Wave animation on all open cells
    const allCells = Array.from(boardEl.children);
    const boardRect = boardEl.getBoundingClientRect();
    const centerR = Math.floor(rows / 2);
    const centerC = Math.floor(cols / 2);

    allCells.forEach((cell, idx) => {
      const r = Math.floor(idx / cols);
      const c = idx % cols;
      if (!revealed[r][c]) {
        setTimeout(() => { cell.classList.add('flag-win'); }, Math.random() * 300);
        return;
      }
      const dist = Math.sqrt((r - centerR) ** 2 + (c - centerC) ** 2);
      setTimeout(() => {
        cell.classList.add('win-flash');
      }, dist * 60);
    });

    // 2. Show overlay message
    setTimeout(() => {
      overlayMsg.classList.add('show');
    }, 400);

    // 3. Launch particles in bursts
    cancelAnimationFrame(animFrame);
    particles = [];

    const burst = (delay, count) => {
      setTimeout(() => {
        spawnParticles(count);
        if (particles.length > 0 && !animFrame) animateParticles();
        else animateParticles();
      }, delay);
    };

    burst(300, 80);
    burst(700, 60);
    burst(1100, 80);
    burst(1500, 50);
    burst(2000, 40);

    // 4. Hide overlay after a moment
    setTimeout(() => {
      overlayMsg.classList.remove('show');
      overlayMsg.classList.add('hide');
      setTimeout(() => overlayMsg.classList.remove('hide'), 500);
    }, 2500);
  }

  initGame();
</script>
</body>
</html>
